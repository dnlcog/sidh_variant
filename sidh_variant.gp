default(parisizemax, 2000000000);
t = 't;
y = 'y;
x = 'x;
w = 'w;
v = 'v;

define_gen_for_embedding(g : t_FFELT, h : t_FFELT) =
{
  my(g_mod, h_mod, f);
  
  if(g.p != h.p,
    error("Those fields do not have the same characteristic."));
    
  if(poldegree(h.mod) % poldegree(g.mod) != 0,
    error("The field generated by h cannot be an extension of the field generated by g."));

  if(poldegree(g.mod) == poldegree(h.mod),
    return(h));
    
  g_mod = subst(g.mod, variable(g.mod), x);
  h_mod = subst(h.mod, variable(h.mod), y);
  f = h^0 * subst(polrootsff(g_mod, g.p, h_mod)[1].pol, y, h);
  
  return(f);
}

emb(g, f, g_elt) =
{
  if(type(g_elt) == "t_FFELT", return(f^0 * subst(g_elt.pol, variable(g_elt.pol), f)),
    type(g_elt) == "t_INTMOD", return(g_elt),
    type(g_elt) == "t_INT", return(lift(Mod(g_elt, g.p))),
    error("Wrong type for g_elt"))
}

apply_emb(g, f, my_list) =
{
  for(i = 1, length(my_list),
    my_list[i] = emb(g, f, my_list[i])
  );

  return(my_list);
}

apply_emb_isogeny(g, f, phi) =
{
  my(E, F, G, H, Gvec);
  E = apply_emb(g, f, phi[1]);
  [F, G, H] = phi[2];
  F = Pol(apply_emb(g, f, Vec(F)), variable(F));
  H = Pol(apply_emb(g, f, Vec(H)), variable(H));
  Gvec = Vec(G);
  for(i = 1, length(Gvec),
    if(variable(Gvec[i]),
      Gvec[i] = Pol(apply_emb(g, f, Vec(Gvec[i])), variable(Gvec[i])),
      Gvec[i] = emb(g, f, Gvec[i])
    )
  );
  G = Pol(Gvec, variable(G));
  return([E, [F, G, H]]);
}

inv_emb(g, f, h_elt) =
{
  if(h_elt^(p^2) != h_elt, error("Not a Fp2 element"));
  if(type(h_elt) == "t_FFELT",
    if(poldegree(h_elt.pol) > 0,
      a = pollead(h_elt.pol)/pollead(f.pol);
      b = polcoeff(h_elt.pol, 0) - a*polcoeff(f.pol, 0);
      return(a*g + b),
      return(polcoeff(h_elt.pol, 0))),
    type(h_elt) == "t_INTMOD", return(h_elt),
    type(h_elt) == "t_INT", return(lift(Mod(h_elt, g.p))),
    error("Wrong type for h_elt"))
}

apply_inv_emb(g : t_FFELT, f : t_FFELT, my_list) =
{
  for(i = 1, length(my_list),
    my_list[i] = inv_emb(g, f, my_list[i])
  );

  return(my_list);
}

apply_inv_emb_isogeny(g : t_FFELT, f : t_FFELT, phi) =
{
  my(E, F, G, H, Gvec);
  E = apply_inv_emb(g, f, phi[1]);
  [F, G, H] = phi[2];
  F = Pol(apply_inv_emb(g, f, Vec(F)), variable(F));
  H = Pol(apply_inv_emb(g, f, Vec(H)), variable(H));
  Gvec = Vec(G);
  for(i = 1, length(Gvec),
    if(variable(Gvec[i]),
      Gvec[i] = Pol(apply_inv_emb(g, f, Vec(Gvec[i])), variable(Gvec[i])),
      Gvec[i] = inv_emb(g, f, Gvec[i])
    )
  );
  G = Pol(Gvec, variable(G));
  return([E, [F, G, H]]);
}

broker_ss_gen(p : t_INT) =
{
  my(E, q, P, j, a);
  
  if(p == 2,
      E = ellinit([0, 0, 1, 0, 0], p),
  
    Mod(p, 4) == 3,
      E = ellinit([-1, 0], p),

    q = 3;
    while(kronecker(-q, p) >= 0,
      q = nextprime(q+1);
      while(Mod(q, 4) == 1,
	q = nextprime(q+1);
      )
    );
    
    if(q == 3,
        E = ellinit([0, 1], p),
      P = polclass(-q);
      j = polrootsmod(P, p)[1];
      a = 27 * j / (4 * (1728 - j));
      E = ellinit([a, -a], p)
    )
  );

  return(E);
}

get_point_order_le(E, l, e, order) =
{
  P = [0];
  while(1,
    random_point = random(E);
    P = ellmul(E, random_point, order);
    R = ellmul(E, P, l^(e-1));
    if(R != [0],
      R = ellmul(E, R, l);
      while(R != [0],
        P = ellmul(E, P, l);
	R = ellmul(E, R, l);
      );
      break;
    );
  );
  return(P);
}  

torsion_subgroup_basis(p, fp2_gen, E1, l, e) =
{
  my(m, phi, factors, extension_degree, ext_gen, fp2_in_ext_gen,
    P_stage, i, j, E, torsion_points, f_fp2, f_ext, x, ordinates,
    old_ext_gen, embedding_ext_gen, point, P, Q, temp, root);
  
  m = l^e;

  extension_degree = 1;
  while(Mod(p^(2*extension_degree)-1, l^e)||Mod(l^(e-1)*(l-1), extension_degree),
    extension_degree++;
  );
  ext_gen = ffgen(p^(2 * extension_degree), w);
  fp2_in_ext_gen = define_gen_for_embedding(fp2_gen, ext_gen);
  E = ellinit(apply_emb(fp2_gen, fp2_in_ext_gen, E1[1..5]));
  order = ellcard(E);
  while(Mod(order, l^(2*e)),
    extension_degree += extension_degree;
    ext_gen = ffgen(p^(2 * extension_degree), w);
    fp2_in_ext_gen = define_gen_for_embedding(fp2_gen, ext_gen);
    E = ellinit(apply_emb(fp2_gen, fp2_in_ext_gen, E1[1..5]));
    order = ellcard(E);
  );  
  
  print(concat("    Extension degree : ", Str(extension_degree)));
  
  order = order/l^(2*e);
  while(!Mod(order, l), order = order/l);
  issquare(order, &order);

  P = get_point_order_le(E, l, e, order);
  print("    Found P.");

  Q = [0];
  
  if(E[4] == 0 && lift(Mod(p, 3)^(2*extension_degree)) == 2,
    root = polrootsff(ext_gen^0 * (t^2 + t + 1))[1];
    Q = [root*P[1],P[2]],
    E[5] == 0 && lift(Mod(p, 4)^(2*extension_degree)) == 3,
    root = polrootsff(ext_gen^0 * (t^2 + 1))[1];
    Q = [-P[1], root*P[2]];
  );
    
  while(ellweilpairing(E, P, Q, m)^(l^(e-1)) == 1,
    Q = get_point_order_le(E, l, e, order);
  );
  print("    Found Q.");

  return([fp2_in_ext_gen, [P, Q]])
}

isogeny_l_e(p, fp2_gen, E1, l, e, PQR_crt) =
{
  my(le, fp2_in_ext_gen, R, phi, E, keys, ext_gen, PQRlist, phi_ext, kernel_polynomial,
    kernel_point, temp);
  le = l^e;
  [fp2_in_ext_gen, R] = mapget(PQR_crt, le);
  mapdelete(PQR_crt, le);
  R = R[1];
  E_fp2 = ellinit(E1[1..5]);
  E_ext = ellinit(apply_emb(fp2_gen, fp2_in_ext_gen, E1[1..5]));

  for(i = 1, e,
    print(concat(concat(concat("    Isogeny ", Str(i)), " of degree "), Str(l)));
    le = le/l;
    kernel_point = ellmul(E_ext, R, le);

    \\With Kohel formula.

    kernel_polynomial_ext = Pol(1*fp2_in_ext_gen^0, x);
    temp = kernel_point;
    for(i=1, ((l-1)/2) - 1,
      kernel_polynomial_ext *= x - temp[1];
      temp = elladd(E_ext, kernel_point, temp);
    );
    kernel_polynomial_ext *= x - temp[1];
    kernel_polynomial_fp2 = Pol(apply_inv_emb(fp2_gen, fp2_in_ext_gen, Vec(kernel_polynomial_ext)), x);
    phi_fp2 = ellisogeny(E_fp2, kernel_polynomial_fp2);
    phi_ext = apply_emb_isogeny(fp2_gen, fp2_in_ext_gen, phi_fp2);

    \\With Velu formula.
/*
    phi_ext = ellisogeny(E_ext, kernel_point);
    phi_fp2 = apply_inv_emb_isogeny(fp2_gen, fp2_in_ext_gen, phi_ext);
*/
    
    if(le>=l, R = ellisogenyapply(phi_ext[2], R));
    E_fp2 = ellinit(phi_fp2[1]);
    E_ext = ellinit(phi_ext[1]);
    
    keys = Vec(PQR_crt);
    for(i = 1, length(keys),
      [ext_gen, PQRlist] = mapget(PQR_crt, keys[i]);
      mapdelete(PQR_crt, keys[i]);
      phi_ext = phi_fp2;
      phi_ext = apply_emb_isogeny(fp2_gen, ext_gen, phi_ext);
      for(i = 1, length(PQRlist), PQRlist[i] = ellisogenyapply(phi_ext[2], PQRlist[i]));
      mapput(PQR_crt, keys[i], [ext_gen, PQRlist]);
    );
  );

  return([ellinit(phi_fp2[1]), PQR_crt])
}

keygen(p, fp2_gen, E1, N, l, e, my_crt, m, n, other_crt) =
{
  my(PQR_crt, ext_gen, PQ, E, R);
  
  PQR_crt = other_crt;

  print("Computing kernel subgroup generator");
  for(i = 1, length(l),
    [ext_gen, PQ] = mapget(my_crt, l[i]^e[i]);
    E = ellinit(apply_emb(fp2_gen, ext_gen, E1[1..5]));
    R = elladd(E, ellmul(E, PQ[1], m), ellmul(E, PQ[2], n));
    mapput(PQR_crt, l[i]^e[i], [ext_gen, [R]]);
  );

  E = E1;

  for(i = 1, length(l),
    print(concat("Isogeny of degree ", Str(l[i]^e[i])));
    [E, PQR_crt] = isogeny_l_e(p, fp2_gen, E, l[i], e[i], PQR_crt);
  );

  return([E, PQR_crt]);
}

genNANB(p) =
{
  my(bound, np, n, l, b, NA, NB, lA, lB, eA, eB, mylist, e, temp);
  temp = length(binary(p))*2;
  while(1,
    np = 0;
    l = 2;
    while(1,
      for(i = 1, 2, l = nextprime(l+1));
      np += 2;
      bound = 2^((temp+lift(Mod(-temp, np)))/np);
      if(l > bound, break);
    );
    np -= 2;
    bound = 2^((temp+lift(Mod(-temp, np)))/np);
    np = floor(np/2);
    [NA, NB] = [1, 1];
    [lA, eA, lB, eB] = [Vec(0, np), Vec(0, np), Vec(0, np), Vec(0, np)];
    mylist = List();
  
    l = 2;
    for(i = 1, 2 * np,
      l = nextprime(l+1);
      e = logint(bound, l);
      listput(mylist, l^e)
    );

    listsort(mylist);

    for(i = 1, np,
      if(mylist[2*i-1] != 1,
        [lA[i], eA[i]] = factor(mylist[2*i-1])[1,];
      );
      if(mylist[2*i] != 1,
        [lB[i], eB[i]] = factor(mylist[2*i])[1,];
      );
      NA *= mylist[2*i-1];
      NB *= mylist[2*i];
    );

    if(NA > p/10,
      break,
      temp+=1);
  );

  return([NA, lA, eA, NB, lB, eB]);
}

crt_to_file(crt, name) =
{
  my(str, keys);
  keys = Vec(crt);
  str = Strprintf("\ncrt%s = Map();\n\n", name);
  for(i=1, length(keys),
    [fp2, PQ] = mapget(crt, keys[i]);
    str = Strprintf("%sext = ffgen(Pol(Mod(1, p) * Vec(%s), w), w);\n", str, Str(fp2.mod));
    str = Strprintf("%sfp2 = ext^0 * subst(%s, w, ext);\n", str, Str(fp2.pol));
    str = Strprintf("%smapput(crt%s, %d, [fp2, [[ext^0 * subst(%s, w, ext), ext^0 * subst(%s, w, ext)], [ext^0 * subst(%s, w, ext), ext^0 * subst(%s, w, ext)]]]);\n\n", str, name, keys[i], Str(PQ[1][1].pol), Str(PQ[1][2].pol), Str(PQ[2][1].pol), Str(PQ[2][2].pol))
  );
  return(str);
}

write_params(params) =
{
  my(p, f, E, NA, lA, eA, NB, lB, eB, crtA, crtB, str);
  
  [p, f, E, NA, lA, eA, NB, lB, eB, crtA, crtB] = params;
  
  str = "my(p, f, E, NA, lA, eA, NB, lB, eB, crtA, crtB, ext, fp2, PQ);\n\n";
  str = Strprintf("%sp = %s ;\n\n", str, Str(p));
  str = Strprintf("%sf = ffgen(Pol(Mod(1, p) * Vec(%s), v), v);\n\n", str, Str(f.mod));
  str = Strprintf("%sE = %s;\nfor(i=1, 5, E[i] = f^0 * subst(E[i], v, f));\n\
E = ellinit(E);\n\n", str, E[1..5]);
  str = Strprintf("%s[NA, NB] = [%d, %d] ;\n", str, NA, NB);
  str = Strprintf("%slA = %s;\nlB = %s;\n", str, Str(lA), Str(lB));
  str = Strprintf("%seA = %s;\neB = %s;\n\n", str, Str(eA), Str(eB));

  str = Strprintf("%s%s%s", str, crt_to_file(crtA, "A"), crt_to_file(crtB, "B"));
  str = Strprintf("%s\n[p, f, E, NA, lA, eA, NB, lB, eB, crtA, crtB];\n\n", str);
  
  return(str);
}

sidh_param(p : t_INT) =
{
  my(f, E, NA, lA, eA, NB, lB, eB, crtA, crtB, params, ext_genA, ext_genB, extA, extB);

  iferr(
    params = read(concat("params_", Str(p)));
    print("Parameters read from file"),
    e,
    if(errname(e)=="e_FILE",
  
      f = ffgen(p^2, v);
      E = ellinit(elltwist(ellinit(f^0 * broker_ss_gen(p)[1..5]))[1..5]);
      print(concat("Curve : ", Str(E[1..5])));
      
      [NA, lA, eA, NB, lB, eB] = genNANB(p);
      printf("NA : %d = %s^%s\nNA = %s*p\n", NA, Str(lA), Str(eA), NA/p*1.0);
      printf("NB : %d = %s^%s\nNB = %s*p\n", NB, Str(lB), Str(eB), NB/p*1.0);
    
      crtA = Map();
      crtB = Map();
  
      print("Comupting crts");
      for(i = 1, length(lA),
        print(concat("  Alice : ", Str(lA[i]^eA[i])));
        mapput(crtA, lA[i]^eA[i], torsion_subgroup_basis(p, f, E, lA[i], eA[i]));
        print(concat("  Bob : ", Str(lB[i]^eB[i])));
        mapput(crtB, lB[i]^eB[i], torsion_subgroup_basis(p, f, E, lB[i], eB[i]));
      );
  
      params = [p, f, E, NA, lA, eA, NB, lB, eB, crtA, crtB];
      write(concat("params_", Str(p)), write_params(params));
      ,
      print(errname(e));
      print(e);
      error("Unexpected roblem when reading the parameters file.");
    )
  );
  return(params);
}

randsubgroup(N) =
{
  my(m, n);
  [m, n] = [0, 0];
  while(gcd(m, N) != 1 && gcd(n, N) != 1,
    m = random(N);
    n = random(N);
  );
  return([m, n]);
}

sidh_exchange(params) =
{
  my(p, mA, nA, mB, nB, EA, phi_crtB, EB, phi_crtA, EsA, EsB, dump);

  [p, f, E, NA, lA, eA, NB, lB, eB, crtA, crtB] = params;
  
  print("Genrating secret parameters");
  [mA, nA] = randsubgroup(NA);
  [mB, nB] = randsubgroup(NB);

  print1("Computing Alice's public data : "); gettime();
  [EA, phi_crtB] = keygen(p, f, E, NA, lA, eA, crtA, mA, nA, crtB);
  A1 = gettime();
  print1(A1);print(" ms.");
  
  print("Computing Bob's public data"); gettime();
  [EB, phi_crtA] = keygen(p, f, E, NB, lB, eB, crtB, mB, nB, crtA);
  B1 = gettime();
  print1(B1);print(" ms.");

  print("Computing Alice's key"); gettime();
  [EsA, dump] = keygen(p, f, EB, NA, lA, eA, phi_crtA, mA, nA, Map());
  A2 = gettime();
  print1(A2);print(" ms.");

  print("Computing Bob's key"); gettime();
  [EsB, dump] = keygen(p, f, EA, NB, lB, eB, phi_crtB, mB, nB, Map());
  B2 = gettime();
  print1(B2);print(" ms.");

  if(EsA.j != EsB.j, error("ERROR: the shared keys don't match! Here's the secret keys:"));

  iferr(dump = readstr("statschristophe.csv"),E,write("statschristophe.csv", "p bit length,p,A1,A2,B1,B2"));
  write1("statschristophe.csv", Strprintf("%d,%d,%d,%d,%d,%d\n", length(binary(p)), p, A1, A2, B1, B2));

  return(EsA.j);
}

sidh(p) =
{
  my(f, E, NA, lA, eA, NB, lB, eB, crtA, crtB);
  print(concat("Characteristic : ", Str(p)));
  print("Computing parameters");
  params = sidh_param(p);

  print();
  print("*** key exchange ***");
  key = sidh_exchange(params);
  print();
  print(concat(concat("*** key = ", Str(key)), " ***"));
  return(key);
}

pbit = 58;
p = 1;
{
while(!isprime(p),
  p = randomprime([2^pbit,2^(pbit+1)-1]);
);}
res = sidh(p);

